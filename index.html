
<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qualis Artifex — Library (V18)</title>

  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#0f0e0d;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .wrapper{position:relative;width:100vw;height:100vh;isolation:isolate;}
    .bg{position:absolute;inset:0;overflow:hidden;z-index:0}
    .bg::before{content:"";position:absolute;inset:0;background:#151311 var(--bg) center/cover no-repeat;filter:contrast(1.03) saturate(0.98);}
    canvas#dust{position:absolute;inset:0;z-index:1;mix-blend-mode:screen;pointer-events:none}
    .hotspot{position:absolute;z-index:2;display:block;
      left:calc(var(--x)*1%); top:calc(var(--y)*1%);
      width:calc(var(--w)*1%); height:calc(var(--h)*1%);
      background:transparent; border:none; cursor:pointer; text-indent:-9999px; overflow:hidden;}
    .back{position:absolute;z-index:3;left:12px;top:12px;background:rgba(20,20,20,.55);color:#e9e3d7;border:1px solid rgba(255,255,255,.25);border-radius:10px;padding:8px 12px;text-decoration:none}
    .back:hover{filter:brightness(1.05)}
  </style>

<style>:root{ --bg: url('./front-page.jpg'); }</style>


  <style>
    /* Slower page transitions w/ gentle curve */
    .wrapper{ opacity:0; filter:blur(0.6px);
      transition: opacity .60s cubic-bezier(.22,.61,.36,1), filter .60s ease; }
    .wrapper.ready{ opacity:1; filter:blur(0); }
    .wrapper.transitioning{ opacity:0; filter:blur(2px); }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .wrapper{ transition:none !important; filter:none !important; }
      .wrapper.ready,.wrapper.transitioning{ opacity:1; filter:none; }
    }

    /* Active plaque hover hint (very subtle) */
    a.hotspot[data-active="true"]:hover{ background:rgba(255,224,160,0.06); box-shadow:0 0 0 1px rgba(255,200,0,0.22) inset; }
    a.hotspot[data-active="true"]{ cursor:pointer; }
    /* Inert plaques already have default cursor inline */

    /* Keyboard focus for accessibility (only when tabbed) */
    a.hotspot:focus-visible{ outline:2px dashed rgba(255,220,160,.45); outline-offset:2px; }
  </style>


  <style>
    a.hotspot:hover, a.hotspot:focus{ outline:none !important; box-shadow:none !important; border:none !important; }
  </style>


  <style>
    a.hotspot:hover, a.hotspot:focus { outline:none !important; box-shadow:none !important; border:none !important; }
  </style>

</head><body>
<div class="stage">
  <svg id="scene"
       viewBox="0 0 1228 819"
       preserveAspectRatio="xMidYMid meet"
       style="width:100%; height:100%; display:block; background:#151311">
    <image href="./front-page.jpg" x="0" y="0" width="1228" height="819" />
    <g id="hotspot-layer"></g>
  </svg>

  <div id="ui" style="position:absolute; inset:auto 1rem 1rem auto; display:flex; gap:.5rem;">
    <button id="toggleEdit">Adjust Hotspots</button>
    <button id="copyJson" style="display:none">Copy JSON</button>
  </div>
</div>

<script>
/* === 1) Hotspot config (image-space pixels, based on 1228×819) === */
let hotspots = [
  { id:"ap",      href:"ap-reading.html",                                           x:175, y:207, w:117, h:110 },
  { id:"corno",   href:"cornology.html",                                            x:322, y:191, w:123, h:112 },
  { id:"practice",href:"practice.html",                                             x:756, y:213, w:248, h:103 },
  { id:"blank",   href:"#",                                                         x:239, y:611, w:118, h:75  },
  { id:"textbook",href:"lower2.html",                                               x:395, y:607, w:121, h:79  },
  { id:"notes",   href:"https://qualisartifex1.github.io/LatinNotes/",              x:542, y:606, w:123, h:83  },
  { id:"qb",      href:"quiz-bowl.html",                                            x:696, y:607, w:122, h:79  },
  { id:"flash",   href:"https://qualisartifex1.github.io/FlashCardsAllSubjects/",   x:848, y:609, w:123, h:78  },
];

/* Load any saved tweaks from localStorage */
try {
  const saved = JSON.parse(localStorage.getItem("qa_hotspots"));
  if (Array.isArray(saved)) hotspots = hotspots.map(h => saved.find(s => s.id===h.id) || h);
} catch {}

/* === 2) Render === */
const svg = document.getElementById('scene');
const layer = document.getElementById('hotspot-layer');

function render(edit=false) {
  layer.innerHTML = '';
  hotspots.forEach(h => {
    const a = document.createElementNS('http://www.w3.org/2000/svg','a');
    a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', h.href);
    if (/^https?:/.test(h.href)) { a.setAttribute('target','_blank'); a.setAttribute('rel','noopener'); }

    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', h.x); r.setAttribute('y', h.y);
    r.setAttribute('width', h.w); r.setAttribute('height', h.h);
    r.setAttribute('rx', 4); r.setAttribute('ry', 4);
    r.dataset.id = h.id;

    if (!edit) {
      r.setAttribute('fill','transparent');
      r.setAttribute('class','hit');
    } else {
      r.setAttribute('fill','rgba(255,215,160,.18)');
      r.setAttribute('stroke','rgba(255,230,180,.9)');
      r.setAttribute('stroke-width','1.5');
      r.style.cursor = 'move';
    }
    a.appendChild(r);
    layer.appendChild(a);

    if (edit) makeDraggable(r, h);
  });
}
render(false);

/* === 3) Edit mode toggles === */
const toggleBtn = document.getElementById('toggleEdit');
const copyBtn   = document.getElementById('copyJson');
let editing = false;
let selected = null;

toggleBtn.addEventListener('click', () => {
  editing = !editing;
  toggleBtn.textContent = editing ? 'Exit Adjust Mode' : 'Adjust Hotspots';
  copyBtn.style.display = editing ? 'inline-block' : 'none';
  render(editing);
});

copyBtn.addEventListener('click', async () => {
  const json = JSON.stringify(hotspots, null, 2);
  try { await navigator.clipboard.writeText(json); } catch {}
  localStorage.setItem('qa_hotspots', json);
  alert('Hotspot coordinates copied to clipboard and saved to this device.');
});

/* === 4) Drag + keyboard nudge (works with mouse or touch) === */
function makeDraggable(rect, model) {
  let start = null;

  function pt(evt){
    const ctm = rect.ownerSVGElement.getScreenCTM();
    const e = evt.touches ? evt.touches[0] : evt;
    return {
      x: (e.clientX - ctm.e) / ctm.a,
      y: (e.clientY - ctm.f) / ctm.d
    };
  }
  function down(e){
    e.preventDefault();
    selected = model;
    const p = pt(e);
    start = { p, x:model.x, y:model.y, w:model.w, h:model.h };
    rect.focus?.();
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up, { once:true });
    window.addEventListener('touchmove', move, { passive:false });
    window.addEventListener('touchend', up, { once:true });
  }
  function move(e){
    e.preventDefault();
    if (!start) return;
    const p = pt(e);
    model.x = Math.round(start.x + (p.x - start.p.x));
    model.y = Math.round(start.y + (p.y - start.p.y));
    rect.setAttribute('x', model.x);
    rect.setAttribute('y', model.y);
  }
  function up(){
    start = null;
    localStorage.setItem('qa_hotspots', JSON.stringify(hotspots));
  }

  rect.addEventListener('pointerdown', down);
  rect.addEventListener('touchstart', down, { passive:false });
}

/* Keyboard nudges: arrows move; Alt+arrows resize; Shift = 10px */
window.addEventListener('keydown', (e) => {
  if (!editing || !selected) return;
  const step = e.shiftKey ? 10 : 1;
  let changed = true;
  if (e.altKey) {
    if (e.key === 'ArrowLeft')  selected.w = Math.max(1, selected.w - step);
    else if (e.key === 'ArrowRight') selected.w += step;
    else if (e.key === 'ArrowUp')    selected.h = Math.max(1, selected.h - step);
    else if (e.key === 'ArrowDown')  selected.h += step;
    else changed = false;
  } else {
    if (e.key === 'ArrowLeft')  selected.x -= step;
    else if (e.key === 'ArrowRight') selected.x += step;
    else if (e.key === 'ArrowUp')    selected.y -= step;
    else if (e.key === 'ArrowDown')  selected.y += step;
    else changed = false;
  }
  if (changed) {
    render(true);
    localStorage.setItem('qa_hotspots', JSON.stringify(hotspots));
    e.preventDefault();
  }
});
</script>

<style>
.stage{
  width:100%;
  max-height:100dvh;
  aspect-ratio:1228/819;
  position:relative;
  margin:0 auto;
}
button{
  background:#2b2620; color:#f6e7c6; border:1px solid #a68b5b;
  padding:.5rem .7rem; border-radius:.5rem; font:600 14px system-ui, sans-serif;
}
button:hover{ filter:brightness(1.08); }
.hit:hover{ fill: rgba(255,224,160,0.06); }
</style>





<script>
(function dust(){
  const canvas = document.getElementById('dust');
  const ctx = canvas.getContext('2d');
  const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const shimmerOrigin = { x: 0.06, y: 0.09 };

  let w, h, dpr, motes = [];
  const LAYERS = [
    { z:0.25, count:36, size:[0.6,1.2], speed:[0.02,0.06], opacity:[0.18,0.38], blur:1.2 },
    { z:0.55, count:64, size:[0.9,1.8], speed:[0.04,0.10], opacity:[0.20,0.42], blur:1.6 },
    { z:1.00, count:52, size:[1.2,2.4], speed:[0.06,0.14], opacity:[0.25,0.48], blur:2.4 },
  ];

  let mx=0.5,my=0.45, tx=0.5,ty=0.45;
  const lerp=(a,b,t)=>a+(b-a)*t, clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function size(){ dpr=Math.min(window.devicePixelRatio||1,2); w=innerWidth; h=innerHeight;
    canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
  size(); addEventListener('resize', size);
  function rand(a,b){ return a+Math.random()*(b-a); }
  function makeMote(L){ const c=Math.random()>0.6?'#fff7d6':'#f4e2b5'; return {
    x:Math.random()*w, y:Math.random()*h, r:rand(L.size[0],L.size[1]),
    a:Math.random()*Math.PI*2, s:rand(L.speed[0],L.speed[1])*(reduceMotion?0.3:1),
    o:rand(L.opacity[0],L.opacity[1]), z:L.z, c, tw:Math.random()*200+80, t:Math.random()*Math.PI*2 }; }
  function reset(p,fromTop=false){ p.x=Math.random()*w; p.y=fromTop?-10:Math.random()*h; }
  function init(){ motes=[]; LAYERS.forEach(L=>{ for(let i=0;i<L.count;i++) motes.push(makeMote(L)); }); } init();
  addEventListener('mousemove',e=>{ tx=e.clientX/w; ty=e.clientY/h; },{passive:true});
  const WIND={t:0, px:34, py:46, sx:0.22, sy:0.16};
  function windowShimmer(x,y,t){ const lx=shimmerOrigin.x*w, ly=shimmerOrigin.y*h;
    const dx=(x-lx)/w, dy=(y-ly)/h, d=Math.hypot(dx,dy); const influence=clamp(1-d*2.2,0,1);
    if(influence<=0) return 0; const s=0.08*Math.sin(t/700 + x*0.004 + y*0.003); return s*influence; }
  let last=performance.now();
  function tick(now){ const dt=Math.min(60, now-last); last=now; mx=lerp(mx,tx,0.03); my=lerp(my,ty,0.03);
    ctx.clearRect(0,0,w,h); ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=0.07; ctx.fillStyle='#0c0a07'; ctx.fillRect(0,0,w,h);
    WIND.t+=dt/1000; const windX=reduceMotion?0:WIND.sx*Math.sin(2*Math.PI*WIND.t/WIND.px);
    const windY=reduceMotion?0:WIND.sy*Math.cos(2*Math.PI*WIND.t/WIND.py);
    for(const L of LAYERS){ const shiftX=(mx-0.5)*(1.2-L.z)*12, shiftY=(my-0.5)*(1.2-L.z)*10;
      ctx.shadowBlur=L.blur; ctx.shadowColor='rgba(255,240,210,0.95)';
      for(const p of motes){ if(p.z!==L.z) continue;
        p.a+=(Math.random()-0.5)*0.02;
        p.x+=Math.cos(p.a)*p.s*(0.8+p.z*0.6)+windX*(0.5+p.z*0.8);
        p.y+=Math.sin(p.a)*p.s*0.4+0.015*(1+p.z*1.5)+windY*(0.3+p.z*0.6);
        if(p.x<-20||p.x>w+20||p.y>h+20) reset(p,true);
        p.t+=(2*Math.PI)/p.tw*(dt/1000);
        const tw=0.85+0.15*Math.sin(p.t), sh=windowShimmer(p.x,p.y,now);
        const alpha=clamp(p.o*tw+sh,0,0.85); ctx.globalAlpha=alpha; ctx.fillStyle=p.c;
        ctx.beginPath(); ctx.arc(p.x+shiftX,p.y+shiftY,p.r,0,Math.PI*2); ctx.fill(); }
    }
    ctx.shadowBlur=0; requestAnimationFrame(tick); }
  requestAnimationFrame(tick);
})();
</script>






<script>
(function(){
  const wrap = document.querySelector('.wrapper');

  // 1) Normal load: fade in
  window.addEventListener('DOMContentLoaded', ()=>{
    // Next frame to avoid a flash
    requestAnimationFrame(()=> { if (wrap) wrap.classList.add('ready'); });
  });

  // 2) BFCache restore or tab switching: ensure we're visible again
  window.addEventListener('pageshow', (e)=>{
    if (!wrap) return;
    // On bfcache restore, pageshow fires (often with e.persisted === true)
    wrap.classList.add('ready');
    wrap.classList.remove('transitioning');
  });

  document.addEventListener('visibilitychange', ()=>{
    if (document.visibilityState === 'visible' && wrap){
      wrap.classList.add('ready');
      wrap.classList.remove('transitioning');
    }
  });

  // 3) Prefetch + intercept internal nav; external opens in new tab
  document.querySelectorAll('a.hotspot').forEach(a=>{
    const href = a.getAttribute('href') || '';
    const isExternal = /^https?:\/\//i.test(href);
    const isInternal = !!href && href !== '#' && !isExternal;

    if (isExternal){
      a.setAttribute('target','_blank');
      a.setAttribute('rel','noopener');
      a.dataset.active = 'true';
      return;
    }

    if (isInternal){
      a.dataset.active = 'true';

      // Prefetch target once for smoother nav
      const prefetch = () => {
        if (a.dataset.prefetched) return;
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = href;
        document.head.appendChild(link);
        a.dataset.prefetched = '1';
      };
      a.addEventListener('mouseenter', prefetch, { once:true });
      a.addEventListener('focus', prefetch, { once:true });

      // Intercept clicks: fade out, then navigate
      a.addEventListener('click', (e)=>{
        e.preventDefault();
        if (!wrap){ window.location.href = href; return; }
        wrap.classList.add('transitioning');
        setTimeout(()=>{ window.location.href = href; }, 580); // match your CSS
      });
    }
  });

  // 4) Safety: if something ever leaves us faded, un-fade after a tick
  setTimeout(()=>{ if (wrap) { wrap.classList.add('ready'); wrap.classList.remove('transitioning'); }}, 0);
})();
</script>


</body></html>



