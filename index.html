<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Qualis Artifex â€” Library</title>

  <style>
    /* Mobile-safe baseline (no vh traps, safe-areas respected) */
    html, body {
      margin: 0;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
      min-height: 100dvh;
      background: #0f0e0d;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      -webkit-text-size-adjust: 100%;
    }

    /* Main stage holds dust (behind) + SVG (front) */
    .stage {
      width: 100%;
      max-height: 100dvh;
      aspect-ratio: 1228 / 819;     /* lock frame to your art */
      position: relative;
      margin: 0 auto;
      background: #151311;
      isolation: isolate;
      overflow: hidden;             /* keeps dust from bleeding outside */
    }

    /* Dust must cover the entire stage */
    #dust {
      position: absolute;
      inset: 0;
      /* Crucial: Explicitly set to 100% of parent's computed size */
      width: 100%; 
      height: 100%;
      z-index: 3;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    /* SVG and background art */
    .stage > svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: #151311;
      z-index: 1;
    }

    /* Click targets */
    .hit { fill: transparent; cursor: pointer; }
    .hit:hover { fill: rgba(255,224,160,0.06); }
  </style>
</head>

<body>
  <div class="stage">
    <canvas id="dust"></canvas>

    <svg viewBox="0 0 1228 819" preserveAspectRatio="xMidYMid meet" aria-label="Qualis Artifex Library">
      <image href="./front-page.jpg" x="0" y="0" width="1228" height="819" />

      <a xlink:href="ap-reading.html">
        <rect class="hit" x="178" y="235" width="117" height="110" />
      </a>
      <a xlink:href="cornology.html">
        <rect class="hit" x="324" y="222" width="123" height="112" />
      </a>
      <a xlink:href="practice.html">
        <rect class="hit" x="757" y="242" width="248" height="103" />
      </a>

      <a xlink:href="#" onclick="return false">
        <rect class="hit" x="242" y="573" width="118" height="75" />
      </a>
      <a xlink:href="lower2.html">
        <rect class="hit" x="395" y="571" width="121" height="79" />
      </a>
      <a xlink:href="https://qualisartifex1.github.io/LatinNotes/" target="_blank" rel="noopener">
        <rect class="hit" x="543" y="567" width="123" height="83" />
      </a>
      <a xlink:href="quiz-bowl.html">
        <rect class="hit" x="697" y="567" width="122" height="79" />
      </a>
      <a xlink:href="https://qualisartifex1.github.io/FlashCardsAllSubjects/" target="_blank" rel="noopener">
        <rect class="hit" x="849" y="570" width="123" height="78" />
      </a>
    </svg>
  </div>

  <script>
  (function dust(){
    const canvas = document.getElementById('dust');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const shimmerOrigin = { x: 0.06, y: 0.09 };

    let w, h, dpr, motes = [];
    // Layer parameters (for visibility)
    const LAYERS = [
      { z:0.25, count:50, size:[1.5, 3.0], speed:[0.02,0.06], opacity:[0.35,0.65], blur:2.0 },
      { z:0.55, count:80, size:[2.5, 4.5], speed:[0.04,0.10], opacity:[0.40,0.70], blur:3.5 },
      { z:1.00, count:60, size:[3.5, 6.0], speed:[0.06,0.14], opacity:[0.50,0.85], blur:5.0 },
    ];

    let mx=0.5,my=0.45, tx=0.5,ty=0.45;
    const lerp=(a,b,t)=>a+(b-a)*t, clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

    // Function to set canvas size based on its actual DOM size
    function size(){
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      // Retrieve the current, computed size of the canvas element
      w = canvas.clientWidth; 
      h = canvas.clientHeight;
      // Set the internal drawing surface size
      canvas.width  = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    
    function rand(a,b){ return a + Math.random()*(b-a); }
    function makeMote(L){
      const c = Math.random() > 0.6 ? '#fff7d6' : '#f4e2b5';
      return {
        // Initial position (x, y) uses the calculated 'w' and 'h'
        x:Math.random()*w, y:Math.random()*h, r:rand(L.size[0],L.size[1]),
        a:Math.random()*Math.PI*2, s:rand(L.speed[0],L.speed[1])*(reduceMotion?0.3:1),
        o:rand(L.opacity[0],L.opacity[1]), z:L.z, c, tw:Math.random()*200+80, t:Math.random()*Math.PI*2
      };
    }
    function reset(p,fromTop=false){ p.x=Math.random()*w; p.y=fromTop?-10:Math.random()*h; }
    
    // Initialize particles after size is set
    function init(){ 
        // Only run if w and h have been correctly calculated (i.e., not 0)
        if (w > 0 && h > 0) {
            motes=[]; 
            LAYERS.forEach(L=>{ for(let i=0;i<L.count;i++) motes.push(makeMote(L)); }); 
        }
    }

    // Use ResizeObserver to handle size changes and initial sizing
    const ro = new ResizeObserver(entries => {
      // Re-calculate size when the stage dimensions change
      size();
      // Re-initialize motes with new, correct dimensions to ensure full coverage
      init();
    });
    
    if (canvas.parentElement) {
      ro.observe(canvas.parentElement);
    }

    addEventListener('mousemove',e=>{ tx=e.clientX/w; ty=e.clientY/h; },{passive:true});
    const WIND={t:0, px:34, py:46, sx:0.22, sy:0.16};
    function windowShimmer(x,y,t){
      const lx=shimmerOrigin.x*w, ly=shimmerOrigin.y*h;
      const dx=(x-lx)/w, dy=(y-ly)/h, d=Math.hypot(dx,dy);
      const influence=clamp(1-d*2.2,0,1);
      if(influence<=0) return 0;
      const s=0.08*Math.sin(t/700 + x*0.004 + y*0.003);
      return s*influence;
    }

    // Ensure initial size and particle creation happens *before* the animation loop starts
    size();
    init();

    let last=performance.now();
    function tick(now){
      const dt=Math.min(60, now-last); last=now;
      mx=lerp(mx,tx,0.03); my=lerp(my,ty,0.03);

      ctx.clearRect(0,0,w,h);
      ctx.globalCompositeOperation='source-over';
      ctx.globalAlpha=0.07;
      ctx.fillStyle='#0c0a07';
      ctx.fillRect(0,0,w,h);

      WIND.t+=dt/1000;
      const windX=reduceMotion?0:WIND.sx*Math.sin(2*Math.PI*WIND.t/WIND.px);
      const windY=reduceMotion?0:WIND.sy*Math.cos(2*Math.PI*WIND.t/WIND.py);

      for(const L of LAYERS){
        const shiftX=(mx-0.5)*(1.2-L.z)*12, shiftY=(my-0.5)*(1.2-L.z)*10;
        ctx.shadowBlur=L.blur; ctx.shadowColor='rgba(255,240,210,0.95)';
        for(const p of motes){
          if(p.z!==L.z) continue;
          p.a+=(Math.random()-0.5)*0.02;
          p.x+=Math.cos(p.a)*p.s*(0.8+p.z*0.6)+windX*(0.5+p.z*0.8);
          p.y+=Math.sin(p.a)*p.s*0.4+0.015*(1+p.z*1.5)+windY*(0.3+p.z*0.6);
          // Check boundaries using the correct 'w' and 'h'
          if(p.x<-20||p.x>w+20||p.y>h+20) reset(p,true);
          p.t+=(2*Math.PI)/p.tw*(dt/1000);
          const tw=0.85+0.15*Math.sin(p.t), sh=windowShimmer(p.x,p.y,now);
          const alpha=clamp(p.o*tw+sh,0,0.95);
          ctx.globalAlpha=alpha; ctx.fillStyle=p.c;
          ctx.beginPath(); ctx.arc(p.x+shiftX,p.y+shiftY,p.r,0,Math.PI*2); ctx.fill();
        }
      }
      ctx.shadowBlur=0;
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
